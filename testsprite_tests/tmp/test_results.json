[
  {
    "projectId": "848927f2-6e41-4e75-b178-ca196856614b",
    "testId": "0457f20d-3449-4d2e-9f24-140aadc0c447",
    "userId": "443834b8-20b1-703c-b746-51ff57f30226",
    "title": "TC_BE001-API Authentication Endpoint",
    "description": "Test authentication API endpoints for login, registration, and token validation",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\nHEADERS_JSON = {\"Content-Type\": \"application/json\"}\n\ndef test_api_authentication_endpoint():\n    session = requests.Session()\n\n    # Registration - create a test user\n    register_payload = {\n        \"email\": \"andersonnarciso@gmail.com\",\n        \"password\": \"q1q2q3q4q5\"\n    }\n    try:\n        register_response = session.post(\n            f\"{BASE_URL}/auth/register\",\n            json=register_payload,\n            headers=HEADERS_JSON,\n            timeout=TIMEOUT\n        )\n        # Registration might return 201 Created or 200 OK depending on implementation\n        assert register_response.status_code in (200, 201), f\"Registration failed: {register_response.text}\"\n        register_data = register_response.json()\n        assert \"id\" in register_data or \"user\" in register_data, \"Registration response missing user id info\"\n\n    except requests.exceptions.RequestException as e:\n        # It is possible user already exists; So just print for now but continue test\n        # For strict testing, could fail here, but we continue to test login & token validation\n        print(f\"Registration request error or user may already exist: {e}\")\n\n    # Login - authenticate with credentials\n    login_payload = {\n        \"email\": \"andersonnarciso@gmail.com\",\n        \"password\": \"q1q2q3q4q5\"\n    }\n    login_response = session.post(\n        f\"{BASE_URL}/auth/login\",\n        json=login_payload,\n        headers=HEADERS_JSON,\n        timeout=TIMEOUT\n    )\n    assert login_response.status_code == 200, f\"Login failed: {login_response.text}\"\n    login_data = login_response.json()\n    assert \"access_token\" in login_data, \"Login response missing access_token\"\n    access_token = login_data[\"access_token\"]\n\n    # Validate token - using token validation endpoint\n    validate_headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n    validate_response = session.get(\n        f\"{BASE_URL}/auth/validate-token\",\n        headers=validate_headers,\n        timeout=TIMEOUT\n    )\n    assert validate_response.status_code == 200, f\"Token validation failed: {validate_response.text}\"\n    validate_data = validate_response.json()\n    assert validate_data.get(\"valid\") is True, \"Token is not valid according to validation endpoint\"\n\ntest_api_authentication_endpoint()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 61, in <module>\n  File \"<string>\", line 23, in test_api_authentication_endpoint\nAssertionError: Registration failed: Proxy server error: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-01T17:01:59.730Z",
    "modified": "2025-10-01T17:03:03.627Z"
  },
  {
    "projectId": "848927f2-6e41-4e75-b178-ca196856614b",
    "testId": "168da5ee-a44d-4c33-ae9e-f5db113ab7ea",
    "userId": "443834b8-20b1-703c-b746-51ff57f30226",
    "title": "TC_BE002-Document Analysis API",
    "description": "Test document analysis endpoints for file upload, processing, and result retrieval",
    "code": "import requests\nimport base64\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nUSERNAME = \"andersonnarciso@gmail.com\"\nPASSWORD = \"q1q2q3q4q5\"\nAUTH_TOKEN = base64.b64encode(f\"{USERNAME}:{PASSWORD}\".encode()).decode()\nHEADERS_AUTH = {\n    \"Authorization\": f\"Basic {AUTH_TOKEN}\"\n}\nTIMEOUT = 30\n\ndef test_document_analysis_api():\n    document_id = None\n    try:\n        # Step 1: Upload a document file for analysis\n        upload_url = f\"{BASE_URL}/analyses/upload\"\n        files = {\n            # Simulate a simple text file upload with legal document content\n            \"file\": (\"test_document.txt\", \"Este é um documento legal para análise.\", \"text/plain\")\n        }\n        response = requests.post(upload_url, headers=HEADERS_AUTH, files=files, timeout=TIMEOUT)\n        assert response.status_code == 201, f\"Upload failed: {response.status_code} - {response.text}\"\n        upload_data = response.json()\n        assert \"documentId\" in upload_data, \"Upload response missing documentId\"\n        document_id = upload_data[\"documentId\"]\n\n        # Step 2: Initiate document analysis specifying AI provider and template (assuming payload structure)\n        analyze_url = f\"{BASE_URL}/analyses/{document_id}/start\"\n        payload = {\n            \"aiProvider\": \"OpenAI GPT-5\",\n            \"template\": \"Brazilian Legal Template\"\n        }\n        headers = HEADERS_AUTH.copy()\n        headers[\"Content-Type\"] = \"application/json\"\n        response = requests.post(analyze_url, json=payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 202, f\"Analysis start failed: {response.status_code} - {response.text}\"\n        analysis_data = response.json()\n        assert \"analysisId\" in analysis_data, \"Analysis start response missing analysisId\"\n        analysis_id = analysis_data[\"analysisId\"]\n\n        # Step 3: Poll for analysis completion (simulate with retries)\n        result_url = f\"{BASE_URL}/analyses/{document_id}/result\"\n        analysis_result = None\n        for _ in range(10):\n            resp = requests.get(result_url, headers=HEADERS_AUTH, timeout=TIMEOUT)\n            if resp.status_code == 200:\n                res_data = resp.json()\n                if res_data.get(\"status\") == \"completed\":\n                    analysis_result = res_data\n                    break\n                elif res_data.get(\"status\") == \"failed\":\n                    assert False, \"Document analysis failed\"\n            elif resp.status_code == 202:\n                # analysis still in progress\n                time.sleep(3)\n                continue\n            else:\n                assert False, f\"Unexpected status fetching analysis result: {resp.status_code} - {resp.text}\"\n        assert analysis_result is not None, \"Analysis did not complete in expected time\"\n\n        # Step 4: Validate fields in analysis result\n        assert \"summary\" in analysis_result, \"Analysis result missing summary\"\n        assert \"recommendations\" in analysis_result, \"Analysis result missing recommendations\"\n        assert isinstance(analysis_result[\"summary\"], str), \"Summary should be a string\"\n        assert isinstance(analysis_result[\"recommendations\"], list), \"Recommendations should be a list\"\n\n    finally:\n        # Cleanup: delete uploaded document analysis if document_id exists\n        if document_id:\n            delete_url = f\"{BASE_URL}/analyses/{document_id}\"\n            try:\n                del_resp = requests.delete(delete_url, headers=HEADERS_AUTH, timeout=TIMEOUT)\n                assert del_resp.status_code in (200,204), f\"Cleanup delete failed: {del_resp.status_code} - {del_resp.text}\"\n            except Exception as e:\n                print(f\"Error during cleanup deleting document analysis id {document_id}: {e}\")\n\ntest_document_analysis_api()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 79, in <module>\n  File \"<string>\", line 24, in test_document_analysis_api\nAssertionError: Upload failed: 500 - Proxy server error: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-01T17:01:59.734Z",
    "modified": "2025-10-01T17:02:54.302Z"
  },
  {
    "projectId": "848927f2-6e41-4e75-b178-ca196856614b",
    "testId": "0138e92d-aa0f-431e-9751-4387d95f4c98",
    "userId": "443834b8-20b1-703c-b746-51ff57f30226",
    "title": "TC_BE003-Credit System API",
    "description": "Test credit management and billing endpoints",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nAUTH_USERNAME = \"andersonnarciso@gmail.com\"\nAUTH_PASSWORD = \"q1q2q3q4q5\"\nTIMEOUT = 30\n\n\ndef test_credit_system_api():\n    session = requests.Session()\n    session.auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n    }\n\n    # 1. Get current user credits\n    credits_url = f\"{BASE_URL}/api/credits\"\n    resp = session.get(credits_url, headers=headers, timeout=TIMEOUT)\n    assert resp.status_code == 200, f\"Expected 200 OK, got {resp.status_code}\"\n    credits_data = resp.json()\n    assert isinstance(credits_data, dict), \"Credits response is not a JSON object\"\n    assert \"credits\" in credits_data and isinstance(credits_data[\"credits\"], (int, float)), \"Credits field missing or invalid\"\n\n    # 2. Simulate purchase credits (billing endpoint)\n    purchase_url = f\"{BASE_URL}/api/billing/purchase\"\n    purchase_payload = {\n        \"plan_id\": \"basic_plan\",\n        \"payment_method\": \"test_card\",\n        \"amount\": 1000,  # cents or currency smallest unit, depending on impl\n    }\n    purchase_resp = session.post(purchase_url, json=purchase_payload, headers=headers, timeout=TIMEOUT)\n    assert purchase_resp.status_code in (200, 201), f\"Expected 200 or 201, got {purchase_resp.status_code}\"\n    purchase_data = purchase_resp.json()\n    assert \"transaction_id\" in purchase_data, \"Missing transaction_id in purchase response\"\n    assert \"status\" in purchase_data and purchase_data[\"status\"] in [\"success\", \"pending\"], \"Unexpected purchase status\"\n\n    transaction_id = purchase_data.get(\"transaction_id\")\n\n    # 3. Retrieve transaction details\n    transaction_url = f\"{BASE_URL}/api/billing/transactions/{transaction_id}\"\n    transaction_resp = session.get(transaction_url, headers=headers, timeout=TIMEOUT)\n    assert transaction_resp.status_code == 200, f\"Expected 200 OK, got {transaction_resp.status_code}\"\n    transaction_data = transaction_resp.json()\n    assert transaction_data.get(\"transaction_id\") == transaction_id, \"Transaction ID mismatch\"\n    assert transaction_data.get(\"amount\") == purchase_payload[\"amount\"], \"Transaction amount mismatch\"\n    assert transaction_data.get(\"status\") in [\"success\", \"pending\"], \"Invalid transaction status\"\n\n    # 4. Attempt credit deduction for an analysis (simulate usage)\n    deduct_url = f\"{BASE_URL}/api/credits/deduct\"\n    deduct_payload = {\n        \"credits_to_deduct\": 10,\n        \"reason\": \"document_analysis\",\n    }\n    deduct_resp = session.post(deduct_url, json=deduct_payload, headers=headers, timeout=TIMEOUT)\n    assert deduct_resp.status_code == 200, f\"Expected 200 OK, got {deduct_resp.status_code}\"\n    deduct_data = deduct_resp.json()\n    assert deduct_data.get(\"remaining_credits\") is not None, \"Missing remaining_credits after deduction\"\n    remaining_credits = deduct_data[\"remaining_credits\"]\n    assert remaining_credits <= credits_data[\"credits\"] + (purchase_payload[\"amount\"] / 100), \"Remaining credits logic error\"\n\n    # 5. Attempt to deduct more credits than available to test error handling\n    overdraft_payload = {\n        \"credits_to_deduct\": remaining_credits + 1000,\n        \"reason\": \"overdraft_test\",\n    }\n    overdraft_resp = session.post(deduct_url, json=overdraft_payload, headers=headers, timeout=TIMEOUT)\n    assert overdraft_resp.status_code in (400, 403), f\"Expected 400 or 403 for overdraft, got {overdraft_resp.status_code}\"\n    error_data = overdraft_resp.json()\n    assert \"error\" in error_data or \"message\" in error_data, \"Expected error message for overdraft\"\n\n    # 6. Get billing plans list\n    plans_url = f\"{BASE_URL}/api/billing/plans\"\n    plans_resp = session.get(plans_url, headers=headers, timeout=TIMEOUT)\n    assert plans_resp.status_code == 200, f\"Expected 200 OK, got {plans_resp.status_code}\"\n    plans_data = plans_resp.json()\n    assert isinstance(plans_data, list), \"Billing plans response should be a list\"\n    assert any(\"plan_id\" in plan and \"name\" in plan and \"price\" in plan for plan in plans_data), \"Billing plan data incomplete\"\n\n\ntest_credit_system_api()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 82, in <module>\n  File \"<string>\", line 21, in test_credit_system_api\nAssertionError: Expected 200 OK, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-01T17:01:59.739Z",
    "modified": "2025-10-01T17:02:33.482Z"
  },
  {
    "projectId": "848927f2-6e41-4e75-b178-ca196856614b",
    "testId": "48d97916-e118-4714-a542-d3e52f1a17a2",
    "userId": "443834b8-20b1-703c-b746-51ff57f30226",
    "title": "TC_BE004-Batch Processing API",
    "description": "Test batch document processing endpoints",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nauth = HTTPBasicAuth(\"andersonnarciso@gmail.com\", \"q1q2q3q4q5\")\n\ndef test_batch_processing_api():\n    batch_endpoint = f\"{BASE_URL}/api/batch\"\n    headers = {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\"\n    }\n\n    # Example batch payload with multiple documents - simulate minimal viable structure\n    batch_payload = {\n        \"documents\": [\n            {\n                \"title\": \"Contract Agreement\",\n                \"content\": \"Este é um contrato de prestação de serviços...\",\n                \"analysisType\": \"template-based\",\n                \"aiProvider\": \"OpenAI GPT-5\"\n            },\n            {\n                \"title\": \"Legal Notice\",\n                \"content\": \"Notificação extrajudicial para contestação de dívida...\",\n                \"analysisType\": \"template-based\",\n                \"aiProvider\": \"Google Gemini 2.5 Pro\"\n            }\n        ]\n    }\n\n    # Use try-finally to ensure cleanup if resource creation endpoint supports deletion\n    created_batch_id = None\n    try:\n        # Submit batch processing request\n        response = requests.post(\n            batch_endpoint,\n            json=batch_payload,\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 202, f\"Expected 202 Accepted, got {response.status_code}\"\n        response_json = response.json()\n        assert \"batchId\" in response_json, \"Response JSON missing 'batchId'\"\n        created_batch_id = response_json[\"batchId\"]\n\n        # Poll for batch processing status with simple retry\n        status_endpoint = f\"{batch_endpoint}/{created_batch_id}/status\"\n        for _ in range(10):\n            status_response = requests.get(status_endpoint, headers=headers, auth=auth, timeout=TIMEOUT)\n            assert status_response.status_code == 200, f\"Status check failed with {status_response.status_code}\"\n            status_json = status_response.json()\n            status = status_json.get(\"status\")\n            assert status in [\"pending\", \"processing\", \"completed\", \"failed\"], f\"Unexpected status: {status}\"\n            if status == \"completed\":\n                break\n            if status == \"failed\":\n                raise AssertionError(\"Batch processing failed\")\n            # Wait before next status check\n            import time\n            time.sleep(2)\n        else:\n            raise TimeoutError(\"Batch processing did not complete within expected time\")\n\n        # Retrieve batch results\n        results_endpoint = f\"{batch_endpoint}/{created_batch_id}/results\"\n        results_response = requests.get(results_endpoint, headers=headers, auth=auth, timeout=TIMEOUT)\n        assert results_response.status_code == 200, f\"Expected 200 OK from results, got {results_response.status_code}\"\n        results_json = results_response.json()\n        assert isinstance(results_json, dict), \"Results response is not a dict\"\n        assert \"documents\" in results_json, \"Results missing 'documents' key\"\n        assert len(results_json[\"documents\"]) == len(batch_payload[\"documents\"]), \"Mismatch in number of documents processed\"\n        for doc_result in results_json[\"documents\"]:\n            assert \"title\" in doc_result and \"analysis\" in doc_result, \"Each document result must have title and analysis\"\n\n    finally:\n        # Attempt to delete the batch to clean up if API supports DELETE\n        if created_batch_id:\n            delete_endpoint = f\"{batch_endpoint}/{created_batch_id}\"\n            try:\n                del_response = requests.delete(delete_endpoint, headers=headers, auth=auth, timeout=TIMEOUT)\n                # Accept 200 OK or 204 No Content on successful deletion\n                assert del_response.status_code in (200, 204), f\"Failed to delete batch, status code {del_response.status_code}\"\n            except Exception:\n                # Log deletion failure but do not fail test due to cleanup issue\n                pass\n\ntest_batch_processing_api()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 91, in <module>\n  File \"<string>\", line 45, in test_batch_processing_api\nAssertionError: Expected 202 Accepted, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-01T17:01:59.744Z",
    "modified": "2025-10-01T17:02:55.283Z"
  },
  {
    "projectId": "848927f2-6e41-4e75-b178-ca196856614b",
    "testId": "d61eaf44-dd2c-40dc-bbb8-cc4716cf9c41",
    "userId": "443834b8-20b1-703c-b746-51ff57f30226",
    "title": "TC_BE005-Admin API Endpoints",
    "description": "Test administrative endpoints for user management and system configuration",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\nUSERNAME = \"andersonnarciso@gmail.com\"\nPASSWORD = \"q1q2q3q4q5\"\n\nauth = HTTPBasicAuth(USERNAME, PASSWORD)\nheaders = {\n    \"Accept\": \"application/json\",\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_admin_api_endpoints():\n    # 1. Get list of users (Admin)\n    users_resp = requests.get(f\"{BASE_URL}/admin/users\", auth=auth, headers=headers, timeout=TIMEOUT)\n    assert users_resp.status_code == 200, f\"Expected 200, got {users_resp.status_code}\"\n    users_data = users_resp.json()\n    assert isinstance(users_data, list), \"Users response should be a list\"\n\n    # Create a new user to test user management endpoints\n    user_payload = {\n        \"email\": \"testuser1234@example.com\",\n        \"password\": \"TestPass!234\",\n        \"role\": \"user\",\n        \"name\": \"Test User\"\n    }\n\n    user_id = None\n    try:\n        create_resp = requests.post(f\"{BASE_URL}/admin/users\", json=user_payload, auth=auth, headers=headers, timeout=TIMEOUT)\n        assert create_resp.status_code == 201, f\"User creation failed with status {create_resp.status_code}\"\n        created_user = create_resp.json()\n        user_id = created_user.get(\"id\")\n        assert user_id is not None, \"Created user ID should not be None\"\n        assert created_user[\"email\"] == user_payload[\"email\"], \"Created user email mismatch\"\n        assert created_user[\"role\"] == user_payload[\"role\"], \"Created user role mismatch\"\n\n        # 2. Get user info by ID\n        get_user_resp = requests.get(f\"{BASE_URL}/admin/users/{user_id}\", auth=auth, headers=headers, timeout=TIMEOUT)\n        assert get_user_resp.status_code == 200, f\"Get user failed with status {get_user_resp.status_code}\"\n        get_user_data = get_user_resp.json()\n        assert get_user_data[\"email\"] == user_payload[\"email\"], \"Get user email mismatch\"\n\n        # 3. Update the user role and name\n        update_payload = {\n            \"role\": \"admin\",\n            \"name\": \"Updated Test User\"\n        }\n        update_resp = requests.put(f\"{BASE_URL}/admin/users/{user_id}\", json=update_payload, auth=auth, headers=headers, timeout=TIMEOUT)\n        assert update_resp.status_code == 200, f\"Update user failed with status {update_resp.status_code}\"\n        updated_user = update_resp.json()\n        assert updated_user[\"role\"] == \"admin\", \"User role update failed\"\n        assert updated_user[\"name\"] == \"Updated Test User\", \"User name update failed\"\n\n        # 4. Test system configuration retrieval\n        config_resp = requests.get(f\"{BASE_URL}/admin/config\", auth=auth, headers=headers, timeout=TIMEOUT)\n        assert config_resp.status_code == 200, f\"Get config failed with status {config_resp.status_code}\"\n        config_data = config_resp.json()\n        assert isinstance(config_data, dict), \"Config data should be a dictionary\"\n\n        # 5. Test system configuration update (patch/put)\n        # Assuming config is updateable and expects some keys like 'system_mode'\n        config_update_payload = {\n            \"system_mode\": config_data.get(\"system_mode\", \"normal\")\n        }\n        update_config_resp = requests.put(f\"{BASE_URL}/admin/config\", json=config_update_payload, auth=auth, headers=headers, timeout=TIMEOUT)\n        assert update_config_resp.status_code == 200, f\"Update config failed with status {update_config_resp.status_code}\"\n        updated_config = update_config_resp.json()\n        assert \"system_mode\" in updated_config, \"Updated config missing 'system_mode'\"\n\n    finally:\n        # Clean up: delete created user if exists\n        if user_id:\n            del_resp = requests.delete(f\"{BASE_URL}/admin/users/{user_id}\", auth=auth, headers=headers, timeout=TIMEOUT)\n            assert del_resp.status_code in (200, 204), f\"User deletion failed with status {del_resp.status_code}\"\n\ntest_admin_api_endpoints()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 19, in test_admin_api_endpoints\nAssertionError: Expected 200, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-01T17:01:59.749Z",
    "modified": "2025-10-01T17:02:32.715Z"
  },
  {
    "projectId": "848927f2-6e41-4e75-b178-ca196856614b",
    "testId": "1cdf7ecc-6bdc-4cb6-bf11-5d723e16adbb",
    "userId": "443834b8-20b1-703c-b746-51ff57f30226",
    "title": "TC_BE006-Error Handling",
    "description": "Test API error handling and validation",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nAUTH = HTTPBasicAuth(\"andersonnarciso@gmail.com\", \"q1q2q3q4q5\")\nHEADERS = {\"Accept\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_error_handling():\n    try:\n        # Test login with wrong credentials (expecting 401 Unauthorized or similar client error)\n        resp = requests.post(\n            f\"{BASE_URL}/auth/login\",\n            json={\"email\": \"andersonnarciso@gmail.com\", \"password\": \"wrongpassword\"},\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code in (400, 401, 403), \"Expected 400, 401, or 403 for wrong credentials\"\n        json_resp = resp.json()\n        assert any(k in json_resp for k in [\"error\", \"errors\", \"message\"]), \"Error message expected in response body\"\n\n        # Test accessing a protected endpoint without auth (expecting 401)\n        resp = requests.get(f\"{BASE_URL}/analyses\", timeout=TIMEOUT)\n        assert resp.status_code == 401, \"Expected 401 Unauthorized when no auth provided\"\n\n        # Test submission of invalid document analysis request (missing required fields)\n        invalid_payload = {\n            # empty or invalid structure simulating validation error\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/analyses\",\n            auth=AUTH,\n            headers={\"Content-Type\": \"application/json\"},\n            json=invalid_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code == 400, \"Expected 400 Bad Request for invalid analysis payload\"\n        json_resp = resp.json()\n        assert \"errors\" in json_resp or \"error\" in json_resp, \"Expected validation errors in response\"\n\n        # Test creating user with missing required fields to cause validation error\n        invalid_user_payload = {\n            \"email\": \"\",  # empty email to trigger validation error\n            \"password\": \"short\",\n        }\n        resp = requests.post(\n            f\"{BASE_URL}/users\",\n            auth=AUTH,\n            headers={\"Content-Type\": \"application/json\"},\n            json=invalid_user_payload,\n            timeout=TIMEOUT,\n        )\n        assert resp.status_code in (400, 422), \"Expected client error status for invalid user creation\"\n        assert \"error\" in resp.json() or \"errors\" in resp.json(), \"Expected error message for invalid user data\"\n\n        # Test unsupported HTTP method on a valid endpoint (e.g., PUT on landing page)\n        resp = requests.put(f\"{BASE_URL}/landing\", auth=AUTH, timeout=TIMEOUT)\n        assert resp.status_code in (405, 404), \"Expected 405 Method Not Allowed or 404 Not Found for invalid HTTP method\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed unexpectedly: {e}\"\n\ntest_error_handling()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 17, in test_error_handling\nAssertionError: Expected 400, 401, or 403 for wrong credentials\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-01T17:01:59.754Z",
    "modified": "2025-10-01T17:03:10.424Z"
  },
  {
    "projectId": "848927f2-6e41-4e75-b178-ca196856614b",
    "testId": "7f950226-bb5e-4386-9eba-51eb50c233af",
    "userId": "443834b8-20b1-703c-b746-51ff57f30226",
    "title": "TC_BE007-Database Operations",
    "description": "Test database connectivity and data persistence",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nAUTH_USERNAME = \"andersonnarciso@gmail.com\"\nAUTH_PASSWORD = \"q1q2q3q4q5\"\nTIMEOUT = 30\n\ndef test_database_operations():\n    \"\"\"\n    Test database connectivity and data persistence by:\n    1. Creating a new test user record via API (assuming user management endpoint).\n    2. Retrieving the created user.\n    3. Updating the user's data.\n    4. Deleting the user record.\n    This will validate database connectivity and persistence through CRUD operations.\n    \"\"\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    auth = HTTPBasicAuth(AUTH_USERNAME, AUTH_PASSWORD)\n\n    # Sample user data for creation and update\n    user_data_create = {\n        \"email\": \"test_database_ops@example.com\",\n        \"password\": \"SecurePass123!\",\n        \"name\": \"Test Database Ops\",\n        \"role\": \"user\"\n    }\n\n    user_data_update = {\n        \"name\": \"Test Database Ops Updated\"\n    }\n\n    user_id = None\n\n    try:\n        # Create User\n        response_create = requests.post(\n            f\"{BASE_URL}/api/users\",\n            json=user_data_create,\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert response_create.status_code == 201, f\"User creation failed: {response_create.text}\"\n        created_user = response_create.json()\n        assert \"id\" in created_user, \"Created user response missing 'id'\"\n        user_id = created_user[\"id\"]\n\n        # Retrieve User\n        response_get = requests.get(\n            f\"{BASE_URL}/api/users/{user_id}\",\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert response_get.status_code == 200, f\"User retrieval failed: {response_get.text}\"\n        user = response_get.json()\n        assert user.get(\"email\") == user_data_create[\"email\"], \"Retrieved user email mismatch\"\n        assert user.get(\"name\") == user_data_create[\"name\"], \"Retrieved user name mismatch\"\n\n        # Update User\n        response_update = requests.put(\n            f\"{BASE_URL}/api/users/{user_id}\",\n            json=user_data_update,\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert response_update.status_code == 200, f\"User update failed: {response_update.text}\"\n        updated_user = response_update.json()\n        assert updated_user.get(\"name\") == user_data_update[\"name\"], \"User name update failed\"\n\n        # Validate persistence by retrieving again after update\n        response_get_after_update = requests.get(\n            f\"{BASE_URL}/api/users/{user_id}\",\n            headers=headers,\n            auth=auth,\n            timeout=TIMEOUT\n        )\n        assert response_get_after_update.status_code == 200, f\"User retrieval post-update failed: {response_get_after_update.text}\"\n        user_after_update = response_get_after_update.json()\n        assert user_after_update.get(\"name\") == user_data_update[\"name\"], \"Persisted user name mismatch after update\"\n\n    finally:\n        # Cleanup - Delete the user if created\n        if user_id:\n            response_delete = requests.delete(\n                f\"{BASE_URL}/api/users/{user_id}\",\n                headers=headers,\n                auth=auth,\n                timeout=TIMEOUT\n            )\n            assert response_delete.status_code in (200, 204), f\"User deletion failed: {response_delete.text}\"\n\ntest_database_operations()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 98, in <module>\n  File \"<string>\", line 47, in test_database_operations\nAssertionError: User creation failed: Proxy server error: \n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-01T17:01:59.758Z",
    "modified": "2025-10-01T17:02:35.899Z"
  },
  {
    "projectId": "848927f2-6e41-4e75-b178-ca196856614b",
    "testId": "1ac329fe-43df-44d5-940b-9096255245bb",
    "userId": "443834b8-20b1-703c-b746-51ff57f30226",
    "title": "TC_BE008-File Upload API",
    "description": "Test file upload and processing endpoints",
    "code": "import requests\nfrom requests.auth import HTTPBasicAuth\n\nBASE_URL = \"http://localhost:3000\"\nUSERNAME = \"andersonnarciso@gmail.com\"\nPASSWORD = \"q1q2q3q4q5\"\nTIMEOUT = 30\n\n\ndef test_file_upload_and_processing():\n    session = requests.Session()\n    session.auth = HTTPBasicAuth(USERNAME, PASSWORD)\n\n    # Attempt to upload a valid file\n    upload_url = f\"{BASE_URL}/upload\"\n    file_content = b\"\"\"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n    Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"\"\"\n    file_name = \"test_document.txt\"\n\n    files = {\n        \"file\": (file_name, file_content, \"text/plain\"),\n    }\n\n    upload_response = None\n    document_id = None\n\n    try:\n        upload_response = session.post(upload_url, files=files, timeout=TIMEOUT)\n        assert upload_response.status_code == 201 or upload_response.status_code == 200, \\\n            f\"Unexpected upload status code: {upload_response.status_code}\"\n        json_resp = upload_response.json()\n        assert \"documentId\" in json_resp or \"id\" in json_resp, \"Response missing documentId\"\n        document_id = json_resp.get(\"documentId\") or json_resp.get(\"id\")\n        assert isinstance(document_id, str) and len(document_id) > 0, \"Invalid documentId returned\"\n\n        # Trigger processing of the uploaded document\n        process_url = f\"{BASE_URL}/upload/{document_id}/process\"\n        process_response = session.post(process_url, timeout=TIMEOUT)\n        assert process_response.status_code == 200, f\"Processing failed with status {process_response.status_code}\"\n        process_json = process_response.json()\n        assert \"status\" in process_json, \"Processing response missing status\"\n        assert process_json[\"status\"] in [\"processing\", \"completed\"], \"Unexpected processing status\"\n\n        # Optionally, get processing result if completed\n        if process_json[\"status\"] == \"completed\":\n            result_url = f\"{BASE_URL}/upload/{document_id}/result\"\n            result_response = session.get(result_url, timeout=TIMEOUT)\n            assert result_response.status_code == 200, f\"Result retrieval failed with status {result_response.status_code}\"\n            result_json = result_response.json()\n            assert \"analysis\" in result_json or \"result\" in result_json, \"Result missing analysis data\"\n            # Additional assertions could be added here depending on result structure\n\n    finally:\n        # Cleanup: delete uploaded document if API supports it\n        if document_id:\n            delete_url = f\"{BASE_URL}/upload/{document_id}\"\n            try:\n                delete_response = session.delete(delete_url, timeout=TIMEOUT)\n                assert delete_response.status_code in [200, 204], \\\n                    f\"Failed to delete uploaded document with status {delete_response.status_code}\"\n            except Exception:\n                pass\n\n\ntest_file_upload_and_processing()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 65, in <module>\n  File \"<string>\", line 29, in test_file_upload_and_processing\nAssertionError: Unexpected upload status code: 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-01T17:01:59.763Z",
    "modified": "2025-10-01T17:02:37.648Z"
  }
]
